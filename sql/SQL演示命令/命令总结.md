# 一、查询命令
### 0、创建数据库
```sql
create database if not exists fruit_db;
```
### 1、使用数据库
```sql
use fruit_db;
```
### 2、创建一个表单：
```sql
-- 1. 创建表（补充 IF NOT EXISTS 避免重复创建报错）
CREATE TABLE IF NOT EXISTS fruit(
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(20),
    type ENUM('浆果','仁果','瓜果'),
    season ENUM('春','夏','秋','冬'),
    price DECIMAL(5,2),
    date_sale DATE
);
```
查看建表语句：
```sql
SHOW CREATE TABLE fruit;
```
### 3、向这个表单插入数据
```sql
-- 2. 批量插入数据（修正语法错误）
INSERT INTO fruit(
    name,
    type,
    season,
    price,
    date_sale
) VALUES
    ('葡萄','浆果','夏',20.00,'2023-12-01'),   -- 每条数据单独用()包裹，逗号分隔
    ('柿子','浆果','秋',10.00,'2023-01-01'),
    ('橘子','浆果','秋',8.00,'2023-06-01'),
    ('山竹','仁果','夏',12.00,'2023-09-01'),
    ('苹果','仁果','秋',5.00,'2023-10-01'),
    ('梨子','仁果','秋',6.00,'2023-11-01'),
    ('西瓜','瓜果','夏',15.00,'2023-07-01'),
    ('菠萝','瓜果','夏',12.00,'2023-09-01'),
    ('香瓜','瓜果','夏',18.00,'2023-08-01'),
    ('哈密瓜','瓜果','秋',25.00,'2023-08-01');  -- 最后一条末尾只有分号，无多余逗号
```

### 3、select条件查询
上面都是无脑查询，现在，我想要查询单价大于10元的所有水果信息。怎嘛办？
即，我想要`范围查询`怎么办？

```sql
# 1.查询单价大于10元的所有水果信息
select *
from fruit 
where price > 10;

# 2.查询单价在10元到15元之间的所有水果信息
select name 
from fruit 
where price between 10 and 15;
```


### 4、内置函数
> 内置函数一般都在select 子句中使用,而不能在where 等子句中使用
```sql
SUM()、MAX()、MIN()、AVG()、count()

select 
    sum(price) as 总金额,
    max(price) as 最高金额,
    min(price) as 最低金额,
    avg(price) as 平均金额,
    count(*) as 水果数量
from 
    fruit;

-- +-----------+--------------+--------------+--------------+--------------+
-- | 总金额     | 最高金额     | 最低金额     | 平均金额     | 水果数量     |
-- +-----------+--------------+--------------+--------------+--------------+
-- |    131.00 |        25.00 |         5.00 |    13.100000 |           10 |
-- +-----------+--------------+--------------+--------------+--------------+
-- 1 row in set (0.01 sec)

```
特点
 只能用于`select、order by、having`这3个子句，不能用于`where、group by`等其他子句
  王哥不行hh


### 5、分组查询
注意，这里用group by进行分组。`含义是，某一列的相同值会被分为一组。`然后对这些组进行操作。

> 展现的就是`按照分组`的结果了。

#### 5.1查询分组下的具体的水果名
```sql
select type '类型' , GROUP_CONCAT(name) '该分组下的具体水果名' 
from fruit 
group by type;
```
-- +---------+---------------------------------+
-- | 类型    | 该分组下的具体水果名            |
-- +---------+---------------------------------+
-- | 浆果    | 葡萄,柿子,橘子                 |
-- | 仁果    | 山竹,苹果,梨子                 |
-- | 瓜果    | 西瓜,菠萝,香瓜,哈密瓜         |
-- +---------+---------------------------------+
-- 3 rows in set (0.00 sec)

> 可以使用group_concat()函数查看分组中的`其他字段的所有信息`,这里的`GROUP_CONCAT(name)`表示查看该分组下的所有水果名。

#### 5.2查询分组下有多少种水果？
```sql
select type '类型' , count(name) '该分组下的水果有几种？' 
from fruit 
group by type;
```

#### 5.3查询春夏秋冬各有有多少种水果？
```sql
select season '季节' , GROUP_CONCAT(name) '春夏秋冬各有哪几种水果？' 
from fruit 
group by season;
```

### 6、分组查询的条件having

where只能用于select子句的条件查询，having用于group的条件子句

```sql
# 3.查询类型分组下，种类大于3的水果有多少种？

select type '类型' , GROUP_CONCAT(name) '该分组下的具体水果名' 
from fruit 
group by type 
having count(*) > 3;

-- +--------+--------------------------------+
-- | 类型   | 该分组下的具体水果名           |
-- +--------+--------------------------------+
-- | 瓜果   | 西瓜,菠萝,香瓜,哈密瓜          |
-- +--------+--------------------------------+

```

### 7、排序子句order by
查询单价大于10元的所有水果信息，按单价升序排序
```sql
-- 升序
select * 
from fruit 
where price > 10 
order by price asc;

-- 降序
select * 
from fruit 
where price > 10 
order by price desc;
```

### 8、限制行数limit
limit
 限制行数
  语法 limit m , n
   代表只显示从查询结果的m起的n条结果
   默认是m=0

```sql
select * 
from fruit 
where price > 10 
order by price asc;
limit 3
```

## 同为条件查询，where子句和having子句的区别？

### 1.作用对象不同：
- where
  where子句在`数据分组之前起作用`，用于筛选从`原始从数据库中读取的数据行`。它基于表中的列进行条件过滤，决定哪些行能够进入后续的处理阶段，例如聚合计算等。
  作用于原始的总数据行

- having
  having子句在`数据分组之后起作用`，用于`筛选分组后的结果集`。它通常与聚合函数一起使用，根据聚合结果进行条件过滤。
  作用于分组后的子数据组

### 2.语法及使用场景不同：

- where
  where子句可以使用表中的`列名`、`常量`、`表达式`以及比较运算符、逻辑运算符等进行条件判断。
  例如：WHERE column_name > 10。`适用于对原始数据进行基本的筛选`，比如筛选出特定日期范围内的记录、符合特定条件的客户信息等。

- having
  having子句`通常结合聚合函数使用`，例如：HAVING AVG(column_name) > 50。`适用于在对数据进行分组并计算聚合值后`，根据`聚合结果进行进一步筛选的场景`，比如找出平均销售额大于一定值的产品类别等

### 3.性能影响不同：

 - 一般来说，在可以使用where子句进行筛选的情况下`优先使用where子句`，因为它在`数据分组之前进行筛选`，可以减少参与分组和聚合计算的数据量，从而提高查询性能。


 # 二、高级查询
 ## (一)模糊查询
-  关键字： like
 
- 通配符：
   `%`代表任意个单词
   `_`代表一个单词

![like关键词+通配符模糊查询](image.png)

```sql
select * from fruit where name like '%瓜';
select * from fruit where name like '_瓜';
```

## (二) 随机查询
rand()
  需要结合`order by`子句使用，实现`查询顺序的随机化`
   举例
```sql
-- 总体随机和价格随机是一样的，都是随机。所以直接在order by后面加上RAND()
SELECT * FROM fruit ORDER BY RAND();
```

## (三)范围查询
在上面。
无非是在where子句中使用比较运算符（如大于、小于、等于等）来指定范围。

```sql
+、-、*、/、div、%、-(取负)、is null、is not null、in、not in、between A and B、not between A and B
```

## (四)子查询
### 1.定义
子查询是指在一条`select语句`中使用`另一条select语句`。`父查询是依赖于子查询的。`
> 也即，`select套娃查询。`
> 子查询几乎可以在任何子句中使用

### 2.分类
#### 2.1单值子查询
- 定义
  子查询结果返回`一行一列的结果`。也称为 `"标量子查询"`

> 说白了，就是子查询只返回一个结果的查询。

- 拓展
  标量就是`单一`的意思。

```sql
-- 查询价格高于橘子的水果信息
select * 
from fruit 
where price > all(
    select price 
    from fruit 
    where name='橘子'
);
```

#### 2.2多值子查询
- 定义
  
子查询结果返回`一列多行`的结果。多值子查询**一般放在where子句**中，并结合in、all、any、some这四个关键字来使用

> 说白了，就是子查询只返回一个结果的查询。

- 定位
>`多值子查询`一般放在`where子句`中，并结合`in、all、any、some`这`四个关键字`来使用。

|关键字|作用|
|--|--|
|in|**判断**某条记录**是否存在于**子查询返回的结果集中|
|all|代表**所有记录**，表达式需要与子查询返回的结果集中的每条记录进行比较。只有当每条记都满足比较关系时才会返回 true(真)，只要有一条记录不满足比较关系就会返回 false(假)。|
|any/some|表示**任意一条记录**，只要表达式与子查询返回的结果集中的任意一条记录满足比较关系，就会返回 true; 也可以用some替换|

> 这里主要是为了验证是否存在！
- in
```sql
-- 查询和浆果类水果同季中的所有水果信息
select * 
from fruit 
where season in(
    select season 
    from fruit 
    where type='浆果'
);
```


- all
```sql
-- 查询价格高于所有浆果类水果的水果信息
select * 
from fruit 
where price > all(
    select price 
    from fruit 
    where type='浆果'
);
```

- any/some
```sql
-- 查询价格高于任意一个浆果类水果的水果信息（求的是浆果类水果的最低值）
select * 
from fruit 
where price > any(
    select price 
    from fruit 
    where type='浆果'
);
```


#### 2.3关联子查询

- 问题引出：
  如果想要查找 price 大于平均售价的所有记录，那么使用单值子查询就可以轻松实现。现在根据类型(type)进行分组，我们思考这样一个问题：`如何找出每一组中price大于该组平均售价的所有水果呢?`

>这也引出了我们`关联子查询`的定义：

- 定义： 查询操作`需要在分组内部进行的，就要用到关联子查询`
> 简单记忆：当需要"找出每个组中符合某种条件的记录"时，就用关联子查询！

---

- **关联子查询的核心**：子查询中引用了外部查询的列`（f2.type = f1.type）`

- **执行特点**：对外部查询的`每一行都执行一次子查询`

- **适用场景**：需要进行组内比较的情况

- **性能注意**：大数据量时考虑使用JOIN优化


```sql
-- 查询每种类型中价格高于该类型平均售价的水果信息
select * 
from fruit f1 
where price > (
    select avg(price) 
    from fruit f2 
    where f1.type=f2.type
);
```
其中

- 主查询(外查询)为：

`select * from fruit f1`  

f1代表"正在检查的每一行"

- 内部查询（子查询）为：

`select avg(price) from fruit f2 where f1.type=f2.type`  

f2代表"正在计算平均值的行"。

## (五)多表查询
> 也称为多表连接。
### 1.背景引出
- 实际项目
 在实际开发中，我们并不会把`所有数据都放在一个表中`，而往往会将数据拆分到多个表中。
 
 [分表分库]如果把所有数据都放在一个表中，那么不仅维护起来比较麻烦，而且查询时速度也非常慢。将数据拆分到多个表中，不仅可以`减少冗余`，也可以确保数据的一致性和完整性。

- 实例
 fruit表中有一段很长的`info列`，保存的是水果简介。`一般文本很长，而且有不会长久用到`。这时候就会很影响整体查询性能。`将info单独放在一个表里面是很好的。这就是多表查询的实际背景。`

### 2.多表查询的分类
#### 2.1 以行为连接的操作
> 导致列增加，组合后，表的结构不变。

集合运算union
 分类
##### 1.并集[也叫联合查询]
   语法
   ```sql
    select 列名 from 表A union select 列名 from 表B;
  ```

===
```sql
-- 插入数据
INSERT INTO fruit1(
    name,
    type,
    season,
    price,
    date_sale
)
VALUES
(
    '香蕉','浆果','春',10.00,'2023-01-01'
),
(
    '草莓','浆果','夏',15.00,'2023-02-01'
),
(
    '桃子','仁果','秋',20.00,'2023-03-01'
);
```
并集命令：
```sql
select * from fruit union select * from fruit1;
```
结果如下：

![select * from fruit union select * from fruit1;](image-1.png)


##### 2.交集
  需要自己使用子查询完成，mysql只内置了并集union
  语法
  ```sql
   select 列名 from 表A where 列名 in (select 列名 from 表B);
  ```

===

```sql
 SELECT * FROM fruit WHERE name IN (SELECT name FROM fruit1);
```


##### 3.差集
    需要自己使用子查询完成，mysql只内置了并集union
    语法
```sql
select 列名 from 表A where 列名 not in (select 列名 from 表B);
```



- 使用条件

 1. 对于参与求`并集`的表来说，它们的`结构必须完全相同`，包括`列数相同、类型相同`等。

 2. union 语句必须由`两个或两个以上`的 `select` 语句组成，然后 select语句之间使用 `union 关键字`来连接。

 3. 在 union语句中，只能使用一个 `order by`子句或 `limit` 子句，并且它们`必须放在最后一个select语句之后`。

- 说明

 1. 默认会去重，如果想保留，在select后加all

实战：
我们再创建一个和fruit同结构的表单：
```sql
CREATE TABLE IF NOT EXISTS fruit1(
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(20),
    type ENUM('浆果','仁果','瓜果'),
    season ENUM('春','夏','秋','冬'),
    price DECIMAL(5,2),
    date_sale DATE
);
```

====


#### 2.2 以列为连接的操作
> 导致行增加，组合后，表的结构会变化。

连接查询join
##### 1.分类

|连接形式|定义||
|-|-|-|
|内连接 inner join|内连接指的是多个表通过**共享列**来进行连接。在实际开发中，内连接是多表连接中**最常用的**一种方式。||
|外连接 outer join|即在**以列为依据**的连接上，**AB两个表的行的内容包含不相同**。||
|笛卡尔连接|它指的是同时从多个表中查询数据，然后组合返回的数据.||

##### 2.内外连接最大区别
> 内连接、外连接最大的区别就是，内连接只返回AB两个表中**都存在的行**，而外连接则会返回其中一个表中**所有的行**，并将另一个表中**不存在的行**用NULL填充。

===

举例：
我们将水果的详细信息存在fruit1_info表里面：
```sql
create table if not exists fruit1_info(
    id int primary key auto_increment,
    name varchar(20),
    info text
);
```

插入数据：
```sql
insert into fruit1_info(
    name,
    info
)
values
(
    '香蕉','香蕉是一种黄色的水果，通常有大的黄色核， Inside the core is a soft, yellow pulp with a sweet taste. The skin is usually green or yellow. '
),
(
    '草莓','草莓是一种红色的水果，通常有大的红色核， Inside the core is a soft, red pulp with a sweet taste. The skin is usually red. '
),
(
    '桃子','桃子是一种黄色的水果，通常有大的黄色核， Inside the core is a soft, yellow pulp with a sweet taste. The skin is usually green or yellow. '
);
```

#### 1、内连接查询：
 
现在，我们进行基于列的连接，将对应水果和其讲解匹配起来。
```sql
select
    f.name,
    f.type,
    f.season,
    f.price,
    f.data_sale,
    i.info
from
    fruit1 f
inner join
    fruit1_info i
on
    f.name=i.name;
```
---

![结果如图，完成了内连接后，列数增加，我们可以认为结果结构改变了。](image-2.png)

#### 2、外连接查询：
外连接分为左外连接和右外连接。
- 左外连接left join
```sql
select
    f.name,
    f.type,
    f.season,
    f.price,
    f.data_sale,
    i.info
from
    fruit1 f
left join
    fruit1_info i
on
    f.name=i.name;
```
![结果，左连接的表是全的](image-3.png)

- 右外连接right join
```sql
select
    f.name,
    f.type,
    f.season,
    f.price,
    f.data_sale,
    i.info
from
    fruit1 f
right join
    fruit1_info i
on
    f.name=i.name;
```
![结果，右连接的表是全的](image-4.png)

#### 3、笛卡尔连接：
笛卡尔连接是指将两个表中的每一行与另一个表中的`每一行进行组合`，形成一个新的结果集。`结果集的行数等于两个表的行数的乘积。`

> 说白了就是全组合。

```sql
select
    f.name,
    f.type,
    f.season,
    f.price,
    f.data_sale,
    i.info -- 这里显示了两个表的内容。
from
    fruit1 f
cross join
    fruit1_info i;
```
![结果，笛卡尔连接的表是全的](image-5.png)



# 三、增加数据
## (一)组成
```sql 
 insert into子句
 values 子句
```
例如：
```sql
-- 插入1条
insert into fruit1 
values('5','柚子','瓜果','秋','50.00','2025-09-01');

-- 插入2条
insert into fruit1 
values
('6','橙子','浆果','秋','25.00','2025-09-01'),
('7','板栗','仁果','秋','40.00','2025-09-01');
```

## (二)特例
- 顺序不一致
  在插入数据时，insert into 子句中字段名的顺序可以和表原来的字段名的顺序不一致，但是values 子句中值的顺序一定要和 `insert into 子句`中的字段名-一对应。

  另外，如果insert into 子句中`没有指定字段名`，那么values 子句中的值就必须和表中字段的`顺序一致`。

- 插入部分字段
  有时只需要针对某几个字段插入数据，而其他字段都采用默认值。

- replace 语句[针对主键]
  `插入同一主键数据`，数据已经存在，`insert是会报错的`，使用`replace即可`
  使用replace来替换即可

- 针对已有主键的插入。
![已有主键的插入，必须使用replace，使用insert会报错](image-6.png)

```sql
-- 如果使用insert会错误。❌️
insert into fruit2
values
('1','芭蕉','浆果','秋','25.00','2025-09-01');

-- 比如使用replace，将可以覆盖主键。✅️
replace into fruit1
values
('1','芭蕉','浆果','秋','25.00','2025-09-01');
```

# 四、修改数据
## (一)组成
- update 更新数据
 
 组成update set 为某一列设置一个新值
- 说明 一般配合where使用不配合使用就是无差别修改，全改

- 举例
```sql
   update
   set
   为某一列设置一个新值
   where
   筛选出要更新的行
```
实例：
```sql
update fruit1
set
price='50.00'
where
name='柚子';
```

# 四、删除数据
## (一)逐行删除delete
### 1.组成
- delete 删除数据
 
 组成delete from 筛选出要删除的行
- 说明 一般配合where使用不配合使用就是无差别删除，全删

- 举例
```sql
   delete from
   筛选出要删除的行
```
实例：
```sql
delete from fruit1
where
name='柚子';
```

---
### 2.总结
- 语法：delete from 表名;
- 归属 DML：可以实现部分删除
- 性能较差，delete是逐行删除，`每删除一次就在日志文件里面记录一次，性能较差。`
- 自增字段，自增字段的值是上一次加1

## (二)整表删除truncate
### 1.组成
- truncate 删除数据
  组成truncate 表名
- 说明 不能配合where使用，是`无差别删除，全删`

- 举例
```sql
   truncate 表名
```
实例：
```sql
truncate fruit1;
```

---
### 2.总结
- 语法：truncate 表名;
- 归属 DML：可以实现整表删除
- 性能较好，truncate是整表删除，`不会在日志文件里面记录每次删除操作，性能较好。`
- 自增字段，自增字段的值会被重置为初始值

### 补充：何为自增字段？
上述delete和truncate都提到了自增字段，那么`自增字段是什么含义呢？`

>1. 自增字段的基础定义

自增字段（Auto-Increment Column）是数据库中一种特殊的字段类型（如 MySQL 的 AUTO_INCREMENT，核心作用是：当向表中插入新记录时，该字段会自动生成一个唯一的、递增的数值（**默认从 1 开始，每次 + 1**），无需手动赋值，常用于作为表的**主键（保证主键唯一）。**

>2. 结合 DELETE 操作的关键行为

当执行 DELETE FROM 表名;（清空全表）后，**自增字段的 “递增基准”不会重置**，而是保留 “上一次最后生成的值”—— 新插入数据时，自增字段的值 = 上一次最后生成的值 + 1，而非重新从 1 开始。

但是，**如果执行了 TRUNCATE TABLE 表名;（清空全表），则自增字段的 “递增基准”会被重置为默认值 1**。

![自增字段的区别](image-7.png)